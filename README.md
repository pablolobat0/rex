#  Rex: A Custom Language Interpreter

![Rust](https://img.shields.io/badge/Rust-1.82-blue.svg)
![License](https://img.shields.io/badge/License-MIT-green.svg)

**Rex**  is a custom programming language interpreter written in Rust. The project is designed as an educational tool to explore the fundamental concepts of programming language implementation, including lexing, parsing, and evaluation. It serves as a practical introduction to building interpreters and virtual machines. Inspired by the books [Writing An Interpreter in Go](https://interpreterbook.com/) and [Crafting Interpreters](https://craftinginterpreters.com/), it is a stepping stone for understanding how interpreters work under the hood.


The project is divided into **two main components**:
1. **Tree-Walking Interpreter**: A direct evaluation of the abstract syntax tree (AST) for simplicity and educational purposes.
2. **Stack-Based Virtual Machine**: A more efficient interpreter that executes bytecode using a stack-based approach.

## Features

### Core Language Features
- **Arithmetic Operations**: Supports addition, subtraction, multiplication, and division.
- **Boolean Expressions**: Includes boolean literals (`true`, `false`) and logical operations (`&&`, `||`, `!`).
- **Conditionals**: Implements `if-else` expressions for control flow.
  **Loops**: Includes `while` loops for iterative control flow.
- **Functions**: Allows the definition and invocation of user-defined functions, including support for closures.
- **Variables**: Supports variable declarations and scope handling (local and global).
- **String Manipulation**: Basic string operations, including concatenation.

### Interpreter Components
The **Tree-Walking Interpreter** is the first implementation of the language. It directly evaluates the **Abstract Syntax Tree (AST)** generated by the parser. Here's how it works:

1. **Lexer**: Tokenizes the input source code into meaningful tokens (e.g., keywords, identifiers, operators).
2. **Parser**: Converts the tokens into an **AST**, a hierarchical representation of the program's structure.
3. **Evaluator**: Walks the AST, evaluating each node in a recursive manner creating an object representation of each node. For example:
   - For an arithmetic expression like `1 + 2`, it evaluates the left and right operands and applies the operator.
   - For a function call, it evaluates the arguments and executes the function body.

#### Advantages:
- **Simplicity**: Easy to implement and understand, making it ideal for learning purposes.
- **Direct Execution**: No intermediate representation (e.g., bytecode) is needed.

#### Limitations:
- **Performance**: Traversing the AST repeatedly can be slow, especially for large programs.
- **No Optimization**: Lacks the ability to optimize the program before execution.


2. **Stack-Based Virtual Machine**:
   - Executes bytecode instructions using a stack for efficient evaluation.
   - More performant than the tree-walking interpreter.
   - Supports advanced features like closures and upvalues.

### Stack-Based Virtual Machine

The **Stack-Based Virtual Machine (VM)** is a more advanced and efficient implementation of the language. Instead of directly evaluating the AST, it compiles the AST into **bytecode** and executes it using a stack-based approach. Here's how it works:
1. **Lexer**: Tokenizes the input source code into meaningful tokens (e.g., keywords, identifiers, operators).
2. **Compiler**: Is designed as a **single-pass compiler**, meaning it generates bytecode directly from the AST in a single traversal. It converts the tokens into a sequence of bytecode instructions (e.g., `OpCode::Add`, `OpCode::Call`), instructions and values are stored in blocks of bytecode called **chunks**.
3. **Virtual Machine**: Executes the bytecode using a stack:
   - Pushes and pops values onto the stack for operations.
   - Manages function calls, closures, and variable scopes.
   - Handles control flow (e.g., loops, conditionals) using jumps and loops.

#### Advantages:
- **Performance**: Bytecode execution is faster than tree-walking, as it avoids repeated traversal of the AST.
- **Optimization**: The compiler can optimize the bytecode before execution.
- **Scalability**: Better suited for larger and more complex programs.

---
## Grammar (BNF Notation)

### Program Structure
```bnf
<program> ::= <statement_list>
<statement_list> ::= <statement> <statement_list> | <statement>
<statement> ::= <let_statement> 
              | <return_statement> 
              | <expression_statement> 
              | <while_statement>

<let_statement> ::= "let" <identifier> "=" <expression>

<return_statement> ::= "return" <expression>

<expression_statement> ::= <expression>

<while_statement> ::= "while" <expression> <block_statement>
<expression> ::= <prefix_expression> 
               | <infix_expression> 
               | <grouped_expression> 
               | <if_expression> 
               | <function_literal> 
               | <call_expression> 
               | <literal>

<prefix_expression> ::= <prefix_operator> <expression>

<infix_expression> ::= <expression> <infix_operator> <expression>

<grouped_expression> ::= "(" <expression> ")"

<if_expression> ::= "if" <expression> <block_statement> ["else" <block_statement> ]

<function_literal> ::= "fn" "(" <parameters>? ")" <block_statement> 

<call_expression> ::= <expression> "(" <arguments>? ")"

<parameters> ::= <identifier> ("," <identifier>)*

<arguments> ::= <expression> ("," <expression>)*
<literal> ::= <integer_literal> 
            | <float_literal> 
            | <boolean_literal> 
            | <string_literal> 
            | <identifier>

<integer_literal> ::= [0-9]+

<float_literal> ::= [0-9]+ "." [0-9]+

<boolean_literal> ::= "true" | "false"

<string_literal> ::= '"' <characters> '"'

<identifier> ::= [a-zA-Z_][a-zA-Z0-9_]*
<prefix_operator> ::= "-" | "!"

<infix_operator> ::= "+" | "-" | "*" | "/" 
                   | "==" | "!=" | ">" | ">=" | "<" | "<=" 
                   | "&&" | "||"
<block_statement> ::= "{" <statement_list> "}"
```

## Why This Project?

This project was created to:
- Learn the fundamentals of programming language design and implementation.
- Explore the differences between tree-walking interpreters and stack-based virtual machines.
- Gain hands-on experience with Rust, a modern systems programming language.
- Build a foundation for more advanced language implementations in the future.

---

## Getting Started
### Prerequisites
- **Rust**: Ensure you have the latest stable version of Rust installed. You can download it from [rust-lang.org](https://www.rust-lang.org/).
- **Cargo**: Rust's package manager and build system, included with the Rust installation.

### Installation

1. Clone the repository:
   ```bash
   git clone https://github.com/pablolobat0/rex.git
   cd rex
   cargo run
   ```
2. Run the interpreter:
   ```bash
   cargo build
   cd target/debug
   ```
   a. Running the virtual machine version:
   ```bash
   ./rex
   ```
   b. Running the tree-walking version:
   ```bash
   ./rex --ast
   ```


